#!/usr/bin/env ruby
# encoding: UTF-8

$VERBOSE = true

while (index = ARGV.index('-I'))
  _, path = ARGV.slice!(index, 2)
  $: << path
end

# TBD tmp for testing
$: << ::File.join(::File.dirname(__FILE__), "../../oterm/lib")
$: << ::File.join(::File.dirname(__FILE__), "../lib")

require 'optparse'

require 'oterm'
require 'oflow'

$inspector_port = 0
$exit_not_busy = true
$exit_after = nil

$opts = OptionParser.new(%|Usage: oflow [options] <filename>...

Executes flows defined by the files specified. Files can be
 - Ruby .rb
 - OmniGraffle .graffle
 - Visio .vdx
 - .svg
Each file format has a specific expected format.
|)
$opts.on('-s', 'decrease verbosity')                                   { Env.log_level = Env.log_level += 1 }
$opts.on('-v', 'increase verbosity')                                   { Env.log_level = Env.log_level -= 1 }
$opts.on('-b', "don't exit when no longer busy")                       { $exit_not_busy = false }
$opts.on('-e', '--exit-after Integer', Integer, 'exit after <secs>')   { |secs| $exit_after = secs }
$opts.on('-i', '--inspector-port Integer', Integer, 'inspector port')  { |port| $inspector_port = port }
$opts.on('-h', '--help', 'Show this display')                          { puts $opts.help; Process.exit!(0) }
files = $opts.parse(ARGV)

def usage(msg)
  puts msg
  puts $opts.help
  Process.exit!(1)
end

usage('No files specified.') if 0 == files.size()

# Load flow configuration files.
files.each do |file|
  usage("Unknown file type for #{file}.") if (i = file.rindex('.')).nil?
  case file[i + 1..-1].downcase()
  when 'rb'
    load(file)
  when 'graffle'
    OFlow::Graffle.load(file)
  when 'vdx'
    # TBD
    usage("Visio files not supported yet.")
  when 'svg'
    # TBD
    usage("Scalable Vector Graphics files not implemented yet.")
  else
    usage("Unknown file type for #{file}.")
  end
end

inspector = nil
if 0 < $inspector_port
  inspector = OFlow::Inspector.new($inspector_port)
end

# Exit either when processing is complete or if there is an inspector present it
# can be used to force the exit. It is also possible to not exit at all if there
# is an event receiver or generator in a flow.
if !$exit_after.nil?
  if inspector.nil?
    sleep($exit_after)
  else
    done = Time.now() + $exit_after
    while inspector.running && Time.now() < done
      sleep(1.0)
    end
  end  
elsif $exit_not_busy
  ::OFlow::Env.flush()
else !inspector.nil?
  inspector.join()
end
