;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil -*-

^c^d hide subtree
^c^s show subtree

- todo

 - set up log, error, and ignore at start of flow
  - ask actor
 - support aliases

 - make log, error, and ignore reserved names for tasks
  - allow replacement with user supplied


 - add checks and do resolve at end of creation
 - add options
  - log severity
   - overrides general severity

 - make sure links get set up
  - make sure all symbols


 - actor test driver
  - links to driver
  - start with perform()
  - gather link calls
  - user test unit asserts to compare results


 - set up bin with oflow
  - point to ruby config files that defines registration and definitions
  - creates inspector

- example
 - data store
  - handles CRUD and simple list
  - tasks
   - receive request and identify action
    - send to correct task (path)
   - insert
    - json encoded object
    - decode header
    - save
    - reply
 - simple (covers all features)
  - receive json request from simple command line input generator
  - send to 2 tasks, get time and get count
  - join back
  - queue to 2+ sleepers (random sleep)
  - reply



- idea
 - define env
  - require, link, whatever
  - register TaskHandlers with TaskType name
 - should be able to write a program to build a workflow
  - create task
  - hook outputs to other tasks
   - task id
   - op (optional)
   - path to data
  - configure task
   - options that are static
 - should be able to build from the inspector
  - better ability to set local variables that are there next time
   - or maybe implement limited env instead

- language (Ruby)
 - Workflow(name)
  - all commands are in the context of a wf so set the current wf
 - NewTask(name, type)
 - Task.SetOption(opt_id, value)
 - Task.SetOut(target, op, data_path)

 - Workflow is a Task
  - how to connect Workflow inputs and output to inner tasks

- steps
 - registration
  - register task types
   - define TaskHandler
   - register each and verify respond_to
 - define
 - run


Task("foo", Workflow) {
  In(target, op, data_path)
  Task(name, type) {
    Option(bar, value)
    Out(target, op, data_path)
    Out(target, op, data_path)
  }
  name = Task(type) {
  }
  # create a Kernel method for each registered task type
  name = type(bar: value) { |task|
    # how to set the context to new object just created?
    task.Out(target, op, data_path)
  }
  Send(op, data_value)
  name.Send(op, data_value)
  name.Out(target, op, data_path)
}

 - ct (change task)
  - in inspector, show task path
