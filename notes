;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil -*-

^c^d hide subtree
^c^s show subtree

- todo

 - features
  - inspector
  - workqueue task/actor that distributes to 1 or n others based on how busy
  - collector waits for n number of boxes to be recieved before continuing
  - other actors
   - http server
   - cache or persister (write to disk and ready on start)
   - call out using pipe and fork
   - timer
  - file input for configuration
   - .graffle OmniGraffle
   - .svg vector graphics
   - .vdx Visio


- inspector
 - show op & box being worked as well as those in queue
 - show trace if available
 

- example
 - rubygems graphs
  - timer
  - fetch
  - persist
  - http
   - fetch data
   - fetch page template
   - form page
   - respond

 - data store
  - handles CRUD and simple list
  - tasks
   - receive request and identify action
    - send to correct task (path)
   - insert
    - json encoded object
    - decode header
    - save
    - reply
 - simple (covers all features)
  - receive json request from simple command line input generator
  - send to 2 tasks, get time and get count
  - join back
  - queue to 2+ sleepers (random sleep)
  - reply

 - store front?


- idea
 - define env
  - require, link, whatever
  - register TaskHandlers with TaskType name
 - should be able to write a program to build a workflow
  - create task
  - hook outputs to other tasks
   - task id
   - op (optional)
   - path to data
  - configure task
   - options that are static
 - should be able to build from the inspector
  - better ability to set local variables that are there next time
   - or maybe implement limited env instead

- language (Ruby)
 - Workflow(name)
  - all commands are in the context of a wf so set the current wf
 - NewTask(name, type)
 - Task.SetOption(opt_id, value)
 - Task.SetOut(target, op, data_path)

 - Workflow is a Task
  - how to connect Workflow inputs and output to inner tasks

- steps
 - registration
  - register task types
   - define TaskHandler
   - register each and verify respond_to
 - define
 - run


Task("foo", Workflow) {
  In(target, op, data_path)
  Task(name, type) {
    Option(bar, value)
    Out(target, op, data_path)
    Out(target, op, data_path)
  }
  name = Task(type) {
  }
  # create a Kernel method for each registered task type
  name = type(bar: value) { |task|
    # how to set the context to new object just created?
    task.Out(target, op, data_path)
  }
  Send(op, data_value)
  name.Send(op, data_value)
  name.Out(target, op, data_path)
}

 - ct (change task)
  - in inspector, show task path
